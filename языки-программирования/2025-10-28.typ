= 28 октября 2025

Поговорим о ленивых вычислениях. При в этой концепции список бесконечный, а мы оттуда берём элементов столько, сколько нам нужно.

В Haskell рассматривается СГНФ (слабая головная нормальная форма) --- это форма значения, вычисленная с точностью до конструктора. НФ --- это когда мы вычислили всё, а СГНФ --- только до какого-то конструктора.

Мы в любой момент можем обратиться к какой-то части конструктора.

Конструкция ```hs data``` из Haskell аналогична ```sml datatype``` из Standart ML.

#table(columns: (1fr, 1fr), inset: 15pt)[Standart ML][Haskell][
  ```sml datatype```
][
  ```hs data```
][
  ```sml :: []```
][
  ```hs : []```
]

/ Конструктор: --- это функция, возвращающая объект какого-то типа

/ Селектор: --- это функция для доступа к какому-то значению. Выделяют два типа селекторов --- геттеры и сеттеры.

/ Геттер: --- это функция для чтения значения.

/ Сеттер: --- это функция для записи значения.

Сеттеры не имеют смысла в ФЯП согласно определённой парадигме, поэтому считаем, что сеттеры не мутирую объекты, а возвращают новые.

== О бесконечных списках

```hs
ones = 1 : ones -- в SML была бы ошибка определения ones
-- В Haskell же значение ones не вычисляется сразу, поэтому
-- до поры до времени мы можем пользоваться ones.
-- Хвостом является thunk

head ones
-- получили голову. Её можно извлечь, а дальше
-- неизвестный thunk

head (tail ones)
-- берём хвост, который thunk, который на деле 1 : ones,
-- получаем 1.

head (tail (tail ones))
-- получим 1 : 1 : 1 : ones для списка ones.

nat = 1 : map (1+) nat -- для натуральных чисел можно так

nat = 1 : zipWith (+) nat ones -- а можно так
```

=== О диапазонах

```hs
ones = [1, 1..] -- так тоже можно, но не на ЯПах. Это диапазон
nat = [1..]

diap = [2, 3..15]

diap_step = [3, 7..15] -- диапазон с шагом 7

diap_inf = [3..] -- бесконечный диапазон
```

== Вновь о списках

```hs
fact = 1 : zipWith (*) nat fact
-- 0!    : fact * nat
-- fact  = 1, 1, 2, 6, 24, 120, ...
-- * nat = 1  2  3  4  5   6
-- = fact= 1  2  6  24 120 720

fib = 0 : 1 : zipWith (+) fib (tail fib)
-- fib  = 0, 1, 1, 2, 3, 5, 8, 13, ...

-- а ещё лучше:
fib = 0 : 1 : zipWith (+) fib fibTail
  where fibTail = tail fib


take 0 _ = []
take _ [] = []
take n (x : xs) = x : take (n - 1) xs


drop 0 lst = lst
drop _ [] = []
drop n (_ : xs) = drop (n - 1) xs
```

```
- take 4 fibb
0 : 1 : 1 : 2 : []
[0, 1, 1, 2]
```

== Об абстрациях

В Haskell для определения абстракции нужно определить её с помощью ключевого слова ```hs type```, наборов конструкторов и селекторов.

Все остальные методы должны не лезть ниже этой абстракции, иначе при её мзменении придётся перелопатить все функции ниже.

Ещё раз: иерархически абстракция методов выше, чем абстракция конструкторов и селекторов. Разделены они барьером абстракций.

== О классах

В Haskell есть классы (но не из ООП). Ключевое слово ```hs class``` относится к семейству операций. Например:

```hs
class Eq
  (==) v1 v2 => какой-то bool
  /=

class Show
  show v => "..."

class Num
  fromInt Int -> a
  fromInteger Integer -> a
  (+) a -> a -> a
  (+) v1 v2 => сумма
  (-) a -> a -> a
  (-) v1 v2 => v1 + negate v2
  (*) a -> a -> a
  negate a -> a
  negate a => fromInt(0) - a
  abs a -> a
  signum a -> a

class Ord
  >
  <
  >=
  <=
  compare => LT, GT, EQ
```