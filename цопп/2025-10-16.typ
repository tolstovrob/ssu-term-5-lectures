= Мотивация

Олимпиадное программирование --- это в первую очепредь про решение *математических задач* оптимальным способом, а не про написание программ.

Соответственно, упор на лекциях будет именно на идеи, а не на конкретные реализации. Тем не менее, код, конечно, будет иметь место.

Ключ --- в нарешивании задач. Уровень программиста обычно оценивается по рейтингу Codeforces. Рейтинг до 1400 набирается путём хорошей ориентации в коде. Алгоритмы не обязательны!


В среднем, если вы решаете задачу вашего рейтинга, то на контесте вы решите её с вероятностью 0,5. Именно поэтому нужно решать задачи рейтингом выше своего.

Но навык решания алгоритмических задач не особо полезен сам по себе. Чем же олимпиадное программирование полезно? Можно научиться видеть в программах структуры и паттерны, а также лучше писать код в целом. Также у олимпиадников прикольное комьюнити. Все ребята молодцы!


= Асимптотика

/ Асимптотика: --- это инструмент для измерения и и размера рантайма программы.

Давайте в уже написанной программе просто посчитаем количество операций. Например, напишем несложный код на C++:

```cpp
int main() {
  int n;
  cin >> n;
  cout << 2 * n << endl;
  cout << "Hello, World\n";
  return 0;
}
```

Конечно, всё зависит от способа подсчёта операций. Важно тут другое --- _количество операций зависит от количества данных_.

То есть, имеет место функция для оценки сложности:

$ f(n) = 4 $

В нашем случае, функция постоянна, так как количество операций (считая и далее тривиальным способом) равно четырём.

Рассмотрим другой пример:

```cpp
int main() {
  int x;
  cin >> x;
  int s = 0;
  for (int i = 0; i < x; ++i) {
    s += i;
  }
  return 0;
}
```

В данном случае функция будет иметь вид:

$ f(n) = n + 5 $

У нас есть $n$ итераций в цикле, а ещё 4 побочных операций.

Опишем вложенный цикл:
```cpp
int main() {
  int x;
  cin >> x;
  int s = 0;
  for (int i = 0; i < x; ++i) {
    for (int j = 0; j < x; ++j) {
      s += i * j;
    }
  }
  return 0;
}
```

Тут функция уже будет иметь вид:

$ f(n) = n^2 + 5 $

так как теперь у меня для каждой итерации верхнего цикла (коих $n$ штук) будет выполнено $n$ операций.

Для таких оценок придумали нотацию O-большое.

/ O-большое.: Говорят, что $f$ растёт не быстрее, чем $g$, если: $ exists N space forall n in NN space n < N => f (n) lt.eq.slant g (n). $ В таком случае пишут, что $ O(f) = g, $ читая «О-большое $f$ равно $g$»

Даже можно уточнить:

$ exists k > 0 space exists N space forall n > N space f(n) lt.eq.slant k g(n) <==> O(f) = g. $

Что интересно, в случае асимптотики полиномов нам важна лишь старшая его степень, то есть, например:

$ O(4x^2 + x) = O(x^2 + x) = O(x^2). $

Первые две записи не несут особого смысла, поэтому принято писать сразу $O(x^2)$.

Умножение асимптотик приводит к произведению асимптотических функций:

$ O(x^2) dot O(x) = O(x^3). $

Более того, оценка «О-большое» является оценкой сверху, а значит даже линейную сложность можно описать квадратичной асимптотикой.

Это полезно нам, так как в программе мы точно знаем, что примерно $10^9$ тривиальных операций в C++ или $10^6$ --- $10^7$ операций в Python пройдёт за 1 секунду. Соответственно, можно грубо прикинуть, является ли решение оптимальным.

Но вот, например, деление операция менее тривиальная и таких операций мы можем сделать не более $10^8$ за секунду.

== Топ-N асимптотик

=== Константная асимптотика

- Ввод и вывод.
- Функции модуля `math` работают за $O(1)$.
- Вставка `vector.push_back` _амортизированно_.

=== Асимптотика $n log n$

Самая быстрая сортировка работает за это время.

Кстати, логарифм по любому основанию одинаково быстро растёт, что приводит к его исключению в $O$-нотации.

=== Линейная асимптотика

Обычно это итеративные операции над контейнерами.

=== Логарифмическое время

Работа со сбалансированными деревьями. Функция `gcd`.

Что примечательно, почти любую константную сложность можно свести к логарифмической. Зачем? Часто это сильно упрощает идею и жизнь.

Например, алгоритм Евклида (в исходном его представлении) примет вид:

```
gcd(a, b) = gcd(a, b - a); (b >= a)
gcd(0, b) = gcd(b, 0) = 0;
```

Это невыгодно, например, для пары $(10^9, 1)$. Поэтому есть модифицированный алгоритм поиска НОД:

```cpp
while (b - a > 0)
  b -= a
```

Давайте запишем ещё одну оптимизацию: вместо вычитания просто поделим и возьмем округление вверх:

```cpp
int gcd(int a, int b) {
  if (a == 0) return b;
  return gcd(b % a, a);
}
```

Это считаем эталонным решением для gcd. Функция логарифмическая и встроена в stl.

=== Асимптотика $sqrt(n)$

Помним, что это $n^(1/2)$. Пример алгоритма --- проверка на простоту. Вспомним, что делители числа симметричны _примерно_ относительно корня.

Поэтому имеет такую функцию:

```cpp
bool is_prime(int x) {
  if (x == 1) return false;
  for (ind d = 2; d * d <= x; ++d)
    if (x % d == 0) return false;
  return true;
```


= Разбор контеста от 16 октября

A. Очевидно, перебрать до корня.

B. Тут следует просто вспомнить математический вывод алгоритма Евклида и попутно сохранять дополнительную метрику --- целая часть от деления. Но тут была ловушка: по умолчанию ```cpp std::cin``` и ```cpp std::cout``` слишком медленные из-за сброса потоков, поэтому следует оптимизировать код:

```cpp
#include <iostream>

using namespace std;

int main() {
  ios::sync_with_stdio(false);
  cin.tie(NULL);
  cout << "Hello, World!\n"; // теперь не сбрасываем буфер
}
```

Также можно не использовать ```cpp std::endl```, а лишь символ переноса строки. В шаблоне я переопределил это.

Что интересно, в задачах с мультитестером можно сначала прочитать всё содержимое тестов, а лишь затем отдавать ответы. Иногда это полезно

D. Задача нетипичная для лекции. Наша задача --- найти первое число $x$, делящееся $y$.

Сначала решим задачу попроще --- найдём максимальное непревосходящее $x$ число. Ну в рамках последовательности довольно очевидно, что это число будет равно $floor(x / y) times y$. А наименшьшее превосходящее, очевидно, равно $(1 + floor(x / y)) times y$.

Также полезно помнить функцию:

$ ceil(x / y) = floor((x + y - 1) / y), $

пользоваться только этой функцией, а math::ceil не трогать из-за ошибки точности с ```cpp float```!

Итак, идея исходной задачи такова: нам надо найти ближайший момент времени, кратный $a_i$. Значит, надо найти ближайшее число, делящееся на $x$. Для этого пользуемся алгоритмом выше.

= Факторизация чисел

== Математическая прелюдия

/ Факторизация числа: --- это его однозначное разложение на простые множители. Так, число 24 представимо в виде:

$ 24 = 2^3 times 3^1. $

В некоторых задачах удобно использовать факторизацию вместо привычного представления чисел. Часто задачи на теорию чисел, НОД и НОК связаны с факторизацией.

Чтобы найти НОД чисел, нужно взять минимальные общие степени. Так, у чисел $2^2 times 3^3 times 5$ и $2 times 3^5 times 7^2$ НОД будет $2 times 3^3$.

НОК можно найти по формуле:

$ lcm(a, b) = (a b) / gcd(a, b). $

Найти количество различных делителей числа $ x = limits(Pi)_(i = 1)^oo p_i^q_i $ можно по формуле:

$ d(x) = limits(Pi)_(i = 1)^oo (q_i + 1). $

Это очевидно, так как каждая степень даст нам новый делитель (например, степени двойки --- $2, 4, 8, ...$). Можно убедиться комбинаторно, так как перебрав все возможные степени всех простых вхождений получим общее число делителей, равное произведению всех степеней (+1, так как от нуля).

== Алгоритм факторизации

Итак, давайте хранить вектор пар основание--степень:

```cpp
vector<pair<long long>, int> fact;
```

Далее начнём перебор как в проверке на простоту:

```cpp
#include <cassert>

for (ind d = 2; d * d <= x; ++d) {
  if (x % d == 0) {
    // при первой встрече делителя он простой.
    // ведь если бы он был составным, то до этого
    // мы бы встретили простое число --- противоречие

    // В этом случае начнём факторизацию
    int cnt = 0;
    while (x % i == 0) {
      ++cnt;
      x /= i;
    }
    fact.push_back({ i, cnt });

    // тут бы и выйти из цикла, но можно этого не делать,
    // ведь теперь, если дальше встретится новый простой
    // делитель, то он будет отличным от данного и порождать
    // новые группы составных делителей

  }
  // В идеале в конце итераций x должен стать единицей.
  // Проверим наш алгоритм через тесты
  assert(x == 1);
}
```

Ошибка возникнет в таком случае, если мы не дойдём до какого-то простого числа. Такое может возникнуть, например, для числа 17.

Можем заметить, что число, которое останется в конце точно простое. Ведь в противном случае мы бы дошли до его простого делителя и избавились бы от него на более ранней итерации.

Исправим конец алгоритма так:

```cpp
for (ind d = 2; d * d <= x; ++d) {
  // факторизация

  if (x > 1) {
    fact.push_back({ x, 1 });
  }
}
```

=== Отступление про структуры данных

Лучше юзать примитивные структуры: векторы, пары. Множества и карты лучше не использовать. Да, переход по итератору происходит за $O(1)$, но время амортизировано и константа там большая.

=== Про взлом тестов

С помощью ```cpp assert``` там, где нет штрафов, можно получить информацию о непройденных тестах.


== Оценка количества делителей

Сколько максимально делителей существует у чисел до $N$? Эмпирически было выяснено, что такая асимтотика $O(root(3, N))$.

== Поиск всех делителей

Можно не факторизовывать число, а просто пробежаться до корня и вывести корень и число, делённое на корень. Не забудем и обработать корень условием `делитель != число / делитель`.

Напишем теперь код через факторизацию, так как асимптотически это побыстрее. Воспользуемся рекурсией:

```cpp
void brute ( int i
           , long long x
           , const vector<pair<long long, int>> &fact ) {
  if (i == int(fact.size())) {
    cout << x << ' ';
    return;
  }

  // фиксирую степень числа и рекурсивно гуляю по каждому
  // делителю. Конструктивно x всегда делитель
  // оригинального числа. Значит, он точно не будет
  // больше исходного 
  for (int pw = 0; pw <= fact[i].second; ++pw) {
    brute(i + 1, x, fact);
    x *= fact[i].first;
  }
}
```

В 15 строчке может возникнуть переполнение на последней итерации. Но нам всё равно --- ведь мы выйдем из цикла и выйдем из функции.

Выведутся числа не по порядку, а осортированно по степеням делителей: группы делителей с нулевой степенью первого делителя, первой степенью первого делителя, ..., а внутри групп сортировка по степеням второго делителя, а внутри... ну понятно.

Таким образом, решение через факторизацию асимптотически быстрее.
